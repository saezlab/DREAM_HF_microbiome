---
title: "survival"
output: html_document
---

```{r setup, include=FALSE}
# Read data
# source("set_up.R")
#source("read_data.R")
setwd("~/Documents/SAEZ/projects/DREAM_HF_microbiome")
# User submitted model that predicts risk scores for the second (unlabeled) data
# Evaluation: score the solution generated by the user
# This document contains the HF dream challenge modelling

# load libraries and set parameters
library(tidyverse)
library(SIAMCAT)
library(survminer)
library(survival)
library(randomForestSRC)
set.seed(7980)

PARAM <- list()
PARAM$folder.R <- paste0(getwd(), "/")
PARAM$folder.results <- paste0(PARAM$folder.R, "results/")
PARAM$folder.testdata <- paste0(PARAM$folder.R, "data/test/")
PARAM$folder.traindata <- paste0(PARAM$folder.R, "data/train/")

# load the data for simulated data
S1 <- read.csv(file = paste0(PARAM$folder.R, "data/train/phenodata.csv"), row.names=1)
O1 <- read.csv(file = paste0(PARAM$folder.R, "data/train/readcounts.csv"), row.names=1)
# T1 <- read.csv(file = paste0(PARAM$folder.R, "data/train/taxtable.csv"))

# load the data for Finrisk data
S2 <- read.csv(file = paste0(PARAM$folder.R, "data/test/phenodata.csv"), row.names=1)
O2 <- read.csv(file = paste0(PARAM$folder.R, "data/test/readcounts.csv"), row.names=1)
# T2 <- read.csv(file = paste0(PARAM$folder.R, "data/test/taxtable.csv"))
```

```{r loaddata, include=FALSE}
# metadata simulated
meta.train <- S1

# choose only HF cases and eliminate "NA"
meta.train <- meta.train %>%
  filter(Event!="NA")
table(meta.train$Event)
dim(meta.train)

# read files for training data simulated
feat.train <- O1

# remove unmapped
toremove = c("ssRNA_positive-strand_viruses", "1", "0")
feat.train <- feat.train[!rownames(feat.train) %in% toremove, ]
rows=rownames(feat.train)

# Convert all variable types to numeric
feat.train <- as.data.frame(apply(feat.train, 2, as.numeric))  
rownames(feat.train) <- rows

# choose sample data
data.sample.tmp <- feat.train[match(rownames(meta.train), colnames(feat.train))]
dim(data.sample.tmp)
# relative abundance
feat.train.rel <- prop.table(as.matrix(data.sample.tmp), 2)
feat.train.rel <- feat.train.rel[rowSums(feat.train.rel >= 10^-5) >= 2, ]
dim(feat.train.rel)

###############################################################################
# read files for Finrisk test data
# metadata simulated
meta.test <- S2

# choose only HF cases and eliminate "NA"
meta.test <- meta.test %>%
  filter(Event!="NA")
table(meta.test$Event)
dim(meta.test)

# count matrix
feat.test <- O2

# remove unmapped
toremove = c("ssRNA_positive-strand_viruses", "1", "0")
feat.test <- feat.test[!rownames(feat.test) %in% toremove, ]
rows=rownames(feat.test)

# Convert all variable types to numeric
feat.test <- as.data.frame(apply(feat.test, 2, as.numeric))  
rownames(feat.test) <- rows

# choose sample data
data.sample.tmp <- feat.test[match(rownames(meta.test), colnames(feat.test))]
dim(data.sample.tmp)
# relative abundance
feat.test.rel <- prop.table(as.matrix(data.sample.tmp), 2)
feat.test.rel <- feat.test.rel[rowSums(feat.test.rel >= 10^-5) >= 2, ]
dim(feat.test.rel)
```

```{r modelling, include=FALSE}
###############################################################################
# Regression Model
###############################################################################

## CHANGE "num.folds =2, num.resample = 2" to at least 5 or 10, I used 2 for 
## testing purposes in line 136
runsiamcat <- function(featTable, metaTable, fileName, label, case){
# create SIAMCAT object and classify
siamcat <- siamcat(feat=featTable, 
                   meta=metaTable, 
                   label=label, 
                   case=case)
# abundance and prevelance filtering
siamcat <- filter.features(siamcat,
                           filter.method = 'abundance',
                           cutoff=0.0001,
                           verbose=3)
siamcat <- filter.features(siamcat,
                           filter.method = 'prevalence',
                           cutoff = 0.02,
                           feature.type = 'filtered',
                           verbose=3)

# normalize with log.clr
siamcat <- normalize.features(siamcat, 
                              norm.method = "log.std", 
                              feature.type = 'filtered',
                              norm.param = list(log.n0=1e-05, sd.min.q=0.1))

# compute associations 
siamcat <- check.associations(siamcat, feature.type = 'normalized',
                              detect.lim = 10^-5, 
                              plot.type = "quantile.box",
                              fn.plot = paste0(PARAM$folder.results,
                                               Sys.Date(), fileName, 'assoc.plot.pdf'))

# train model
siamcat <- create.data.split(siamcat, num.folds =2, num.resample = 2)  
siamcat <- train.model(siamcat, method = "ridge", verbose = 3)
siamcat <- make.predictions(siamcat)
siamcat <- evaluate.predictions(siamcat)    

# evaluation plot
model.evaluation.plot(siamcat, fn.plot = paste0(PARAM$folder.results, 
                                                Sys.Date(), '.',
                                                fileName, 'eval.plot.pdf'))
# interpretation plot
model.interpretation.plot(siamcat, fn.plot = paste0(PARAM$folder.results, 
                                                    Sys.Date(), '.', 
                                                    fileName,
                                                    'interpret.plot.pdf'),
                          consens.thres = 0.5,
                          detect.lim = 1e-05,
                          heatmap.type = 'zscore')

# save siamcat object
save(siamcat, file = paste0(PARAM$folder.results, 
                            Sys.Date(), '.', 
                            fileName, 
                            'siamcat.Rdata'))
return(siamcat) 
}
# run function with relative abundance (only for categorical variables)
# runsiamcat(feat.train.rel, meta.train, "Simulated_Event", "Event","1")
# runsiamcat(feat.train.rel, meta.train, "simulated_Smoking", "Smoking","1")
# runsiamcat(feat.train.rel, meta.train, "simulated_BPtreatment", "BPtreatment","1")
# runsiamcat(feat.train.rel, meta.train, "simulated_PrevalentDiabetes", "PrevalentDiabetes","1")
# runsiamcat(feat.train.rel, meta.train, "simulated_PrevalentCHD", "PrevalentCHD","1")
# runsiamcat(feat.train.rel, meta.train, "simulated_Sex", "Sex","1")
# 
# runsiamcat(feat.test.rel, meta.test, "Finriks_Event", "Event","1")
# runsiamcat(feat.test.rel, meta.test, "Finriks_Smoking", "Smoking","1")
# runsiamcat(feat.test.rel, meta.test, "Finriks_BPtreatment", "BPtreatment","1")
# runsiamcat(feat.test.rel, meta.test, "Finriks_PrevalentDiabetes", "PrevalentDiabetes","1")
# runsiamcat(feat.test.rel, meta.test, "Finriks_PrevalentCHD", "PrevalentCHD","1")
# runsiamcat(feat.test.rel, meta.test, "Finriks_Sex", "Sex","1")
```

```{r cox, include=FALSE}
###############################################################################
# Multivariate Cox regression analysis
###############################################################################
# A Cox regression of time to death on the time-constant covariates is specified as follow:
# cox ph model: allows both categorical and numeric variables 
# with categorical variable
# we cant estimate survival/hazard  but estimate hazard ratio
cox.mod.simulated <- coxph(Surv(Event_time, Event) ~ BMI + Age + Smoking + PrevalentDiabetes + 
                   SystolicBP + BPtreatment + NonHDLcholesterol + PrevalentCHD + Sex, 
                   data=meta.train)
summary(cox.mod.simulated)

cox.mod.finrisk <- coxph(Surv(Event_time, Event) ~ BMI + Age + Smoking + PrevalentDiabetes + 
                             SystolicBP + BPtreatment + NonHDLcholesterol + PrevalentCHD + Sex,
                         data=meta.test)
summary(cox.mod.finrisk)

# Concordance is similar to AUC in logistic regression
# shows how good is the model 

###############################################################################
# Visualizing the estimated distribution of survival times
# proportion at any given point in time for a particular risk group. 
# The function survfit() estimates the survival proportion, by default at the mean values of covariates.
# Plot the baseline survival function
ggsurvplot(survfit(cox.mod.simulated), data=meta.train, palette = "#2E9FDF",
           ggtheme = theme_minimal())

ggsurvplot(survfit(cox.mod.finrisk), data=meta.test, palette = "#2E9FDF",
           ggtheme = theme_minimal())

# check linearity: 
df=cox.mod.simulated
plot(predict(df), residuals(df, type="martingale"), 
     xlab="fitted value", 
     ylab= "martingale residuals", las=1)
  abline(h=0)
  lines(smooth.spline(predict(df), 
                      residuals(df, type="martingale")), col="red")
  
df=cox.mod.finrisk
plot(predict(df), residuals(df, type="martingale"), 
     xlab="fitted value", 
     ylab= "martingale residuals", las=1)
  abline(h=0)
  lines(smooth.spline(predict(df), 
                      residuals(df, type="martingale")), col="red")

# if it is not linear, we can make the variable as category
###############################################################################
# chekcing proportional hazards assumption
# 1. Ho: hazards are proportional? Check with Schoenfeld test
cox.zph(cox.mod.simulated)
cox.zph(cox.mod.finrisk)

# if pval is larger than 0.05, Ho is true, hazard is proportional for tested variable
  for (i in length(cox.mod.simulated[1])){
    par(mfrow=c(1,1))
    plot(cox.zph(cox.mod.simulated)[i])
    abline(h=0, col=2)
  }

  for (i in length(cox.mod.finrisk[1])){
    par(mfrow=c(1,1))
    plot(cox.zph(cox.mod.finrisk)[i])
    abline(h=0, col=2)
  }
  
# proportinal hazard is there, since 0 line is in btw .95 dash lines
```

```{r , include=FALSE}
# To apply the univariate coxph function to multiple covariates at once, type this:
# controlled covariates
# making formulas
univ_formulas <- sapply(covariates,
                        function(x) as.formula(paste('Surv(Event_time, Event) ~', x)))

univ_models <- lapply( univ_formulas, function(x){coxph(x, data = meta.train)})

# extract data
univ_results <- lapply(univ_models,function(x){return(exp(cbind(coef(x),confint(x))))})
univ_results <- lapply(univ_models,
                       function(x){ 
                         x <- summary(x)
                         p.value<-signif(x$wald["pvalue"], digits=2)
                         wald.test<-signif(x$wald["test"], digits=2)
                         beta<-signif(x$coef[1], digits=2);#coeficient beta
                         HR <-signif(x$coef[2], digits=2);#exp(beta
                         res<-c(beta, HR, wald.test, p.value)
                         names(res)<-c("beta", "HR (95% CI for HR)", "wald.test", 
                                       "p.value")
                         return(res)
                       })
res <- t(as.data.frame(univ_results, check.names = FALSE))
res
###############################################################################
# repeat for finrisk cohort
univ_models <- lapply( univ_formulas, function(x){coxph(x, data = meta.test)})

# extract data
univ_results <- lapply(univ_models,function(x){return(exp(cbind(coef(x),confint(x))))})
univ_results <- lapply(univ_models,
                       function(x){ 
                         x <- summary(x)
                         p.value<-signif(x$wald["pvalue"], digits=2)
                         wald.test<-signif(x$wald["test"], digits=2)
                         beta<-signif(x$coef[1], digits=2);#coeficient beta
                         HR <-signif(x$coef[2], digits=2);#exp(beta
                         res<-c(beta, HR, wald.test, p.value)
                         names(res)<-c("beta", "HR (95% CI for HR)", "wald.test", 
                                       "p.value")
                         return(res)
                       })
res <- t(as.data.frame(univ_results, check.names = FALSE))
res
```

```{r randomforest, include=FALSE}
###############################################################################
# Random survival forest
###############################################################################

# remove nas
meta.train.nona =na.omit(meta.train)
meta.test.nona =na.omit(meta.test)

obj.train <- rfsrc(Surv(Event_time, Event)~., data=meta.train.nona, 
             ntree = 1000, nodesize = 5, nsplit = 50, na.action = c("na.impute"), importance = TRUE)
print(obj.train)

## find interactions, survival setting
find.interaction(obj.train, method = "vimp", outcome.target = "Event_time") #can be event as well
# RSF provides a fully nonparametric measure of variable importance (VIMP). 
# The most common measure is Breiman-Cutler VIMP & is called permutation importance.
jk.obj.train <- subsample(obj.train)
pdf("c", width = 15, height = 20)
par(oma = c(0.5, 10, 0.5, 0.5))
par(cex.axis = 2.0, cex.lab = 2.0, cex.main = 2.0, mar = c(6.0,17,1,1), mgp = c(4, 1, 0))
plot(jk.obj.train, file= paste0(PARAM$folder.results,"VIMPsur.simulated.pdf" ), xlab = "Variable Importance (x 100)", cex = 1.2)
dev.off()


obj.train <- rfsrc(Surv(Event_time, Event)~., data=meta.test.nona, 
             ntree = 1000, nodesize = 5, nsplit = 50, na.action = c("na.impute"), importance = TRUE)
print(obj.train)

## find interactions, survival setting
find.interaction(obj.train, method = "vimp", outcome.target = "Event_time") #can be event as well
# RSF provides a fully nonparametric measure of variable importance (VIMP). 
# The most common measure is Breiman-Cutler VIMP & is called permutation importance.
jk.obj.train <- subsample(obj.train)
pdf("c", width = 15, height = 20)
par(oma = c(0.5, 10, 0.5, 0.5))
par(cex.axis = 2.0, cex.lab = 2.0, cex.main = 2.0, mar = c(6.0,17,1,1), mgp = c(4, 1, 0))
plot(jk.obj.train, file= paste0(PARAM$folder.results,"VIMPsur.finrisk.pdf" ), xlab = "Variable Importance (x 100)", cex = 1.2)
dev.off()

# Doesnt work since we have negative event_time value

# ## obtain Brier score using KM and RSF censoring distribution estimators
# bs.km <- get.brier.survival(obj.train, cens.mode = "km")$brier.score
# bs.rsf <- get.brier.survival(obj.train, cens.mode = "rfsrc")$brier.score
# 
# ## plot the brier score
# plot(bs.km, type = "s", col = 2)
# lines(bs.rsf, type ="s", col = 4)
# legend("bottomright", legend = c("cens.model = km", "cens.model = rfsrc"), fill = c(2,4))

```
